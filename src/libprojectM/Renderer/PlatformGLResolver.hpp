#pragma once

#include "PlatformLoader.hpp"

#include <condition_variable>
#include <cstdint>
#include <memory>
#include <mutex>

namespace libprojectM
{
namespace Renderer
{
namespace Platform
{

/**
 * @brief Backend describing which API/provider the current context appears to be using.
 */
enum class Backend : std::uint8_t
{
    /**
     * Backend detection was not successful or no specific loader is needed (e.g. Apple).
     */
    None = 0,

    /**
     * Detected EGL backend (GL build), or GLES backend (ENABLE_GLES=ON build).
     */
    EglGles = 1,

    /**
     * Detected GLX backend (GL build only).
     */
    GlxGl = 2,

    /**
     * Detected WGL backend (GL build only).
     */
    WglGl = 3,

    /**
     * WegGl proc resolver (Emscripten only).
     */
    WebGl = 4,

    /**
     * User resolver is used, no backend detection.
     */
    UserResolver = 5
};

/**
 * @brief Optional user resolver callback.
 *
 * If provided, it is consulted first when resolving procedure addresses.
 * Return nullptr to allow the resolver to continue probing.
 */
using UserResolver = void* (*)(const char* name, void* userData);

/**
 * @brief Cross-platform runtime GL/GLES resolver.
 *
 * This resolver:
 *  - Supports: EGL, GLES, GLX, WGL, WebGL or a user supplied resolver.
 *  - Platforms: Android, Emscripten, Linux, Mac, Windows.
 *  - Must be initialized after a GL/GLES context has been created and made current.
 *  - Probes for EGL/GLX/WGL by checking for a current context.
 *  - Uses GLAD2 non-MX entrypoints (gladLoadGL / gladLoadGLES2) via a universal resolver.
 *  - Resolves symbols using the following order (GL/GLES):
 *      1) User resolver callback (if any)
 *      2) Platform provider eglGetProcAddress / glXGetProcAddress* / wglGetProcAddress (when available)
 *      3) Global symbol table (RTLD_DEFAULT / main module)
 *      4) Symbols from opened libEGL / libGL / opengl32
 *  - Resolves symbols using the following order (Emscripten):
 *      1) User resolver callback (if any)
 *      2) emscripten_webgl_get_proc_address()
 */
class GLResolver
{
public:
    /**
     * Opaque handle for gl functions.
     */
    using GLapiproc = void*;

    GLResolver() = default;
    ~GLResolver();

    GLResolver(const GLResolver&) = delete;
    auto operator=(const GLResolver&) -> GLResolver& = delete;
    GLResolver(GLResolver&&) = delete;
    auto operator=(GLResolver&&) -> GLResolver& = delete;

    /**
     * @brief Returns the process-wide resolver instance.
     */
    static auto Instance() -> GLResolver&;

    /**
     * @brief Initializes the resolver.
     * This method has to be called at least once for each resolver instance before it is used.
     * May be called multiple times, initialization is done if needed only.
     *
     * @param resolver Optional user resolver callback.
     * @param userData Optional user pointer passed to resolver.
     * @return true if GLAD successfully loaded a backend, false otherwise.
     */
    auto Initialize(UserResolver resolver = nullptr, void* userData = nullptr) -> bool;

    /**
     * @brief Shuts down the resolver and releases library handles.
     */
    void Shutdown();

    /**
     * @brief Returns true if the resolver was successfully initialized.
     */
    auto IsLoaded() const -> bool;

    /**
     * @brief Returns the currently detected backend.
     */
    auto CurrentBackend() const -> Backend;

    /**
     * @brief Resolves a function pointer by consulting all sources in priority order.
     *
     * @param name Function name.
     * @return Procedure address or nullptr.
     */
    auto GetProcAddress(const char* name) const -> GLapiproc;

    /**
     * @brief Resolves a function pointer by consulting all sources in priority order from a static context.
     *
     * @param name Function name.
     * @return Procedure address or nullptr.
     */
    static auto GladResolverThunk(const char* name) -> GLapiproc;
private:
    /**
     * GL resolver function pointer type.
     */
    using GetProcFunc = GLapiproc (*)(const char* name);

    void OpenNativeLibraries();
    void ResolveProviderFunctions();
    void DetectBackend();
    void SetBackendDefault();
    auto LoadGlad() -> bool;
    auto Resolve(const char* name) const -> GLapiproc;

    mutable std::mutex m_mutex;                   //!< Mutex to synchronize initialization and access.
    bool m_loaded{false};                         //!< True if the resolver is initialized.
    bool m_initializing{false};                   //!< True while an Initialize() attempt is in-flight.
    mutable std::condition_variable m_initCv;     //!< Signals completion of Initialize()/Shutdown().
    Backend m_backend{ Backend::None };           //!< Detected GL backend.

    UserResolver m_userResolver{nullptr};         //!< User provided function resolver. Optional, may be null.
    void* m_userData{nullptr};                    //!< User data to pass to user provided function resolver.

    DynamicLibrary m_eglLib;                      //!< EGL library handle. Optional, may be null.
    DynamicLibrary m_glLib;                       //!< GL library handle. Optional, may be null.
    DynamicLibrary m_glxLib;                      //!< GLX library handle. Optional, may be null.

    GetProcFunc m_eglGetProcAddress{nullptr};     //!< Function pointer to EGL proc resolver function.
    GetProcFunc m_glxGetProcAddress{nullptr};     //!< Function pointer to GLX proc resolver function.
    GetProcFunc m_wglGetProcAddress{nullptr};     //!< Function pointer to WGL proc resolver function.
};

} // namespace Platform
} // namespace Renderer
} // namespace libprojectM
